/*
Все логически завершенные фрагменты алгоритма (ввод, вывод, обработка и т.п.) необходимо оформить как подпрограммы.
При разработке интерфейса программы следует предусмотреть:
    - указание формата и диапазона вводимых данных,
    - указание операции, производимой программой (выбор из меню),
    - наличие пояснений при выводе результата, указание формата выводимых данных
    - возможность ввода значений в матрицы вручную (при большой размерности, например, 1000*1000, удобен координатный способ).
    - Возможность просмотра входных и выходных матриц в формате хранения CSR (CSC), в случае маленьких матриц (до 30х30) также в стандартном виде
При тестировании программы необходимо:
    - проверить правильность ввода
    - проконтролировать правильность вывода данных (т.е. их соответствие требуемому формату);
    - oпроверить правильность выполнения операций;
    - обеспечить вывод сообщений при отсутствии входных данных («пустой ввод»);
    - обеспечить вывод сообщений при нулевых результате или вывод
    - нулевого результата при ненулевом входе;
    - обеспечить возможность ввода данных и вывода результата как при малых матрицах, так и при больших (например, 1000 * 1000).
    - сравнить время выполнения стандартного алгоритма обработки матриц и алгоритма обработки разреженных матриц при различной заполненности 
      матриц (от 1 элемента до того количества нулей (в %), при котором становится неэффективно использование алгоритма сокращенного умножения).
    - сравнить объем требуемой памяти для реализации стандартного алгоритма обработки матриц и алгоритма обработки разреженных матриц при
      различном проценте заполнения матриц и при различном их размере.

Следует также протестировать программу при полной загрузке системы, то есть при полном заполнении матриц. 
Программа должна адекватно реагировать на неверный ввод, пустой ввод и выход за границы матрицы или вектора. 
Необходимо тщательно следить за освобождением динамической памяти (если она используется) при окончании программы.
*/

/*
Цель работы: реализация алгоритмов обработки разреженных матриц,
сравнение эффективности применения этих алгоритмов со стандартными
алгоритмами обработки матриц при различном размере матриц и степени
их разреженности.

Вариант 2
Разреженная (содержащая много нулей) матрица хранится в форме 3-х объектов (CSC):
- вектор A содержит значения ненулевых элементов;
- вектор IA содержит номера строк для элементов вектора A;
- вектор JA, в элементе Nk которого находится номер компонент в A и IA, с которых начинается описание столбца Nk матрицы A.
1. Смоделировать операцию сложения двух матриц, хранящихся в этой форме, с получением результата в той же форме.
2. Произвести операцию сложения, применяя стандартный алгоритм работы с матрицами.
3. Сравнить время выполнения операций и объем памяти при использовании этих 2-х алгоритмов при различном проценте заполнения матриц.
*/

/*
Реализуй программу обработки разреженных целочисленных матриц на языке Си.
Матрица хранится в формате 3-х объектов (согласно CSC).
Программа должна:
1. Считывать матрицу из файла
2. Создавать случайную матрицу. Заполнить случайными элементами на введеное от пользвователя кол-во процентов. 
Элементы должны располагаться в случайных местах.
3. Заполнить матрицу в координатном формате.
4. Реализовать сложение двух разряженных матриц, хранящихся в формате CSC.
5. Реализовать сложение двух матриц стандартным алгоритмом (по индексам).

Помимо этого программа должна:
6. Контролировать ввод неправильных значений. Выводить сообщения об ошибках.
7. Каждый ввод должен сопровождаться сообщением, которое содержит диапазон вводимых значений.
8. Возможность просмотра матриц (как входных, так и выходных) в формате CSC, а для маленьких матриц до (30 на 30) в стандартом виде.
9. Сравнить скорость сложение матриц стандартным способом и реализованным в формате CSC. 
    Результат должен выводиться в численном формате (секундах) и процентом соотношении.
Указанные выше операции программа должна выполнять по выбору из меню. Меню реализуется в терминале.
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "io.h"
#include "functions.h"
#include "measure.h"


// Меню программы
void menu() 
{
    int choice;
    CSCMatrix *matrixA = NULL;
    CSCMatrix *matrixB = NULL;
    int rows, cols;
    double percentage;

    int rc = 0;

    do 
    {
        show_menu();
        scanf("%d", &choice);
        clear_input_buffer();
        switch (choice) 
        {
            case 1:
                if (!matrixA)
                {
                    printf("Рабочая матрица не инициализированна. Переключение невозможно.\n");
                    break;
                }
                if (matrixB == NULL) 
                {
                    matrixB = init_csc_matr(matrixA->rows, matrixA->cols, 0);
                    if (!matrixB) 
                    {
                        printf("Ошибка инициализации матрицы B.\n");
                        break;
                    }
                }

                CSCMatrix temp = *matrixA;
                *matrixA = *matrixB;
                *matrixB = temp;
                printf("Матрица успешно сменена! Для правильной работы, пожалуйста проинициализируйте её.\n");
                break;
            case 2:
                printf("Введите количество строк и столбцов (данные ограничены диапазоном [1, 2 147 483 647]: ");
                while (scanf("%d %d", &rows, &cols) != 2 || rows < 1 || cols < 1)
                {
                    printf("Неверный ввод. Повторите попытку: \n");
                    clear_input_buffer();
                }
                clear_input_buffer();
                printf("Введите процент заполненности (0, 100]: ");
                while (scanf("%lf", &percentage) != 1 || percentage < EPS || percentage > 100.0)
                {
                    printf("Неверный ввод. Повторите попытку: \n");
                    clear_input_buffer();
                }
                clear_input_buffer();
                rc = createRandomCSC(&matrixA, rows, cols, percentage);
                if (rc) 
                    break;
                printf("Случайная матрица создана!\n");
                break;
            case 3:
                printf("Введите количество строк и столбцов: ");
                while (scanf("%d %d", &rows, &cols) != 2)
                {
                    printf("Неверный ввод. Повторите попытку: \n");
                    clear_input_buffer();
                }
                clear_input_buffer();
                rc = createMatrixByCoordinates(&matrixA, rows, cols);
                if (rc) 
                    break;
                printf("Матрица успешно создана по введённым координатам!\n");
                break;
            case 4:
                if (!matrixA || !matrixB)
                {
                    printf("Одна из матриц не инициализированна.\n");
                    break;
                }
                else if (!(matrixA->values[0]) || !(matrixB->values[0]))
                {
                    printf("Одна из матриц пустая.\n");
                    break;
                }
                CSCMatrix *result = addCSCMatrices(*matrixA, *matrixB);
                if (!result) break;
                printf("Результирующая матрица.\n");
                if (result->rows < 30 && result->rows < 30)
                {
                    printCSCMatrix(*result);
                    printCSCMatrix_stdView(*result);
                }
                else
                {
                    printCSCMatrix(*result);
                }
                free_csc_matrix(result);
                break;
            case 5:
                if (!matrixA || !matrixB)
                {
                    printf("Одна из матриц не инициализированна.\n");
                    break;
                }
                else if (!(matrixA->values[0]) || !(matrixB->values[0]))
                {
                    printf("Одна из матриц пустая.\n");
                    break;
                }
                int **std_matrixA = create_std_matrix_from_csc(matrixA);
                int **std_matrixB = create_std_matrix_from_csc(matrixB);
                int **res = addStdMatrix(std_matrixA, std_matrixB, matrixA->rows, matrixA->cols);
                printStdMatrix(res, matrixA->rows, matrixA->cols);
                break;
            case 6:
                if (!matrixA)
                {
                    printf("Матрица не инициализированна.\n");
                    break;
                }
                else if (!(matrixA->values[0]))
                {
                    printf("Одна из матриц пустая.\n");
                    break;
                }
                printCSCMatrix(*matrixA);
                break;
            case 7:
                if (!matrixA)
                {
                    printf("Матрица не инициализированна.\n");
                    break;
                }
                else if (!(matrixA->values[0]))
                {
                    printf("Одна из матриц пустая.\n");
                    break;
                }
                printCSCMatrix_stdView(*matrixA);
                break;
            case 8:
                if (!matrixA || !matrixB)
                {
                    printf("Одна из матриц не инициализированна.\n");
                    break;
                }
                else if (!(matrixA->values[0]) || !(matrixB->values[0]))
                {
                    printf("Одна из матриц пустая.\n");
                    break;
                }
                do_measure(matrixA, matrixB);
                break;
            case 9:
                do_all_measures(matrixA, matrixB);
                break;
            case 0:
                printf("Выход...\n");
                break;
            default:
                printf("Неверный ввод! Пожалуйста, выберите допустимый вариант.\n");
        }
    } while (choice != 0);

    free_csc_matrix(matrixA);
    free_csc_matrix(matrixB);
}

int main() 
{
    srand(time(NULL));
    menu();
    return 0;
}